// This file was autogenerated by parse_grammar.lua from carp.ebnf.

/*
 * inline constants: 
 * ALPHANUM        := [0-9a-zA-Z]
 * ATOM            := number | pattern
 | rawstring
 | string
 | char
 | bool
 | symbol

 * BASE16          := '0x' ($HEX)+
 *     ('0x' ([0-9a-fA-F])+)
 * BASE2           := '0b' ($BIN)+
 *     ('0b' ([0-1])+)
 * BASES           := $BASE2 | $BASE16
 *     ('0b' ([0-1])+ | '0x' ([0-9a-fA-F])+)
 * BIN             := [0-1]
 * CHARESC         := '\\"' | "space"
 | "newline"
 | "tab"
 | "backspace"
 | "return"
 | "formfeed"
 | ($UNIESC)
 | ($LOWCHAR)

 *     ('\\"' | "space"
 | "newline"
 | "tab"
 | "backspace"
 | "return"
 | "formfeed"
 | ('\\u' [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F])
 | ([\u0000-\u007F])
)
 * DIGIT           := [0-9]
 * HEX             := [0-9a-fA-F]
 * HIGHCHAR        := [^\u0000-\u007F]
 * LETTER          := [a-zA-Z]
 * LOWCHAR         := [\u0000-\u007F]
 * MAYBESIGNED     := '-'? $(DIGIT)+
 *     ('-'? [0-9]+)
 * PATTERNSIMPLE   := [^\u005E\u0024()\[\]\\"]
 * UNIESC          := '\\u' $HEX $HEX $HEX $HEX
 *     ('\\u' [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F])
 * VALIDCHAR       := [+\-*âˆ•?!><=_:\u9580\u9559]
 */

module.exports = grammar({
  name: 'carp',

  /*
   * carp.ebnf:1
   * extras             ::= { /[\u0020\u0009\u000D\u000A]/ ',' comment }
   */
  extras: $ => [/[\u0020\u0009\u000D\u000A]/, ',', $.comment],
  /*
   * carp.ebnf:3
   * word               ::= identifier
   */
  word: $ => $.identifier,
  /*
   * carp.ebnf:5-9
   * conflicts          ::= {
   *                        { identifier float double }
   *                        { float double }
   *                        { bracketclass }
   *                      }
   */
  conflicts: $ => [[$.identifier, $.float, $.double], [$.float, $.double], [$.bracketclass]],
  rules: {
    /*
     * carp.ebnf:12
     * source           ::= _sexpr*
     */
    source: $ => repeat($._sexpr),
    /*
     * carp.ebnf:14-25
     * _sexpr           ::= ref
     *                    | deref
     *                    | copy
     *                    | quote
     *                    | quasiquote
     *                    | unquotesplicing
     *                    | unquote
     *                    | list
     *                    | staticarray
     *                    | array
     *                    | dictionary
     *                    | $ATOM
     */
    _sexpr: $ => choice(
                   $.ref,
                   $.deref,
                   $.copy,
                   $.quote,
                   $.quasiquote,
                   $.unquotesplicing,
                   $.unquote,
                   $.list,
                   $.staticarray,
                   $.array,
                   $.dictionary,
                   $.number,
                   $.pattern,
                   $.rawstring,
                   $.string,
                   $.char,
                   $.bool,
                   $.symbol
                 ),
    /*
     * carp.ebnf:27-28
     * ref              ::= '&' sexpr
     *                    | '(' 'ref' sexpr* ')'
     */
    ref: $ => choice(seq('&', $._sexpr), seq('(', 'ref', repeat($._sexpr), ')')),
    /*
     * carp.ebnf:30-31
     * deref            ::= '~' sexpr
     *                    | '(' 'deref' sexpr ')'
     */
    deref: $ => choice(seq('~', $._sexpr), seq('(', 'deref', $._sexpr, ')')),
    /*
     * carp.ebnf:33-34
     * copy             ::= '@' sexpr
     *                    | '(' 'copy' sexpr ')'
     */
    copy: $ => choice(seq('@', $._sexpr), seq('(', 'copy', $._sexpr, ')')),
    /*
     * carp.ebnf:36-37
     * quote            ::= ['] sexpr
     *                    | '(' 'quote' sexpr ')'
     */
    quote: $ => choice(seq(/[']/, $._sexpr), seq('(', 'quote', $._sexpr, ')')),
    /*
     * carp.ebnf:39-40
     * quasiquote       ::= '`' sexpr
     *                    | '(' 'quasiquote' sexpr ')'
     */
    quasiquote: $ => choice(seq('`', $._sexpr), seq('(', 'quasiquote', $._sexpr, ')')),
    /*
     * carp.ebnf:42-43
     * unquotesplicing  ::= '%@' sexpr
     *                    | '(' 'unquote-splicing' sexpr ')'
     */
    unquotesplicing: $ => choice(seq('%@', $._sexpr), seq('(', 'unquote-splicing', $._sexpr, ')')),
    /*
     * carp.ebnf:45-46
     * unquote          ::= '%' sexpr
     *                    | '(' 'unquote' sexpr ')'
     */
    unquote: $ => choice(seq('%', $._sexpr), seq('(', 'unquote', $._sexpr, ')')),
    /*
     * carp.ebnf:48
     * list             ::= '(' sexpr* ')'
     */
    list: $ => seq('(', repeat($._sexpr), ')'),
    /*
     * carp.ebnf:50
     * staticarray      ::= '$' array
     */
    staticarray: $ => seq('$', $.array),
    /*
     * carp.ebnf:52
     * array            ::= '[' sexpr* ']'
     */
    array: $ => seq('[', repeat($._sexpr), ']'),
    /*
     * carp.ebnf:54
     * dictionary       ::= '{' sexpr* '}'
     */
    dictionary: $ => seq('{', repeat($._sexpr), '}'),
    /*
     * carp.ebnf:64
     * symbol           ::= identifier ('.' identifier)*
     */
    symbol: $ => seq($.identifier, repeat(seq('.', $.identifier))),
    /*
     * carp.ebnf:66-67
     * bool             ::= 'true'
     *                    | 'false'
     */
    bool: $ => choice('true', 'false'),
    /*
     * carp.ebnf:69
     * identifier       ::= @((($LETTER) | ($DIGIT) | ($VALIDCHAR) | ($HIGHCHAR))+)
     */
    identifier: $ => token(
                       repeat1(choice(/[a-zA-Z]/, /[0-9]/, /[+\-*/?!><=_:\u9580\u9559]/, /[^\u0000-\u007F]/))
                     ),
    /*
     * carp.ebnf:71
     * char             ::= @('\\' (($CHARESC) | [^\s]))
     */
    char: $ => token(
                 seq(
                   '\\',
                   choice(
                     '\\"',
                     "space",
                     "newline",
                     "tab",
                     "backspace",
                     "return",
                     "formfeed",
                     seq('\\u', /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/, /[0-9a-fA-F]/),
                     /[\u0000-\u007F]/,
                     /[^\s]/
                   )
                 )
               ),
    /*
     * carp.ebnf:73
     * string           ::= @('"' [^"\\]* ('\\' /./ [^"\\]*)* '"')
     */
    string: $ => token(seq('"', repeat(/[^"\\]/), repeat(seq('\\', /./, repeat(/[^"\\]/))), '"')),
    /*
     * carp.ebnf:75
     * rawstring        ::= @('r"' ('"' '"' | [^"])* '"')
     */
    rawstring: $ => token(seq('r"', repeat(choice(seq('"', '"'), /[^"]/)), '"')),
    /*
     * carp.ebnf:77
     * pattern          ::= '#"' internalpattern '"'
     */
    pattern: $ => seq('#"', $.internalpattern, '"'),
    /*
     * carp.ebnf:79
     * internalpattern  ::= '^'? (patternescaped | bracketclass | capture | ($PATTERNSIMPLE))+ '$'?
     */
    internalpattern: $ => seq(
                            optional('^'),
                            repeat1(choice($.patternescaped, $.bracketclass, $.capture, /[^\u005E\u0024()\[\]\\"]/)),
                            optional('$')
                          ),
    /*
     * carp.ebnf:81-83
     * patternescaped   ::= '\\' ('1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'a' | 'c' | 'd' | 'g' | 'l' | 'p' | 's' | 'u' | 'w' | 'x' | 'n' | 'r' | 't' | '[' | ']' | '\\' | '$' | '(' | ')' | '^' | '"' | '*' | '.' | '-')
     *                    | '\\b' [^"] [^"]
     *                    | '\\f' bracketclass
     */
    patternescaped: $ => choice(
                           seq(
                             '\\',
                             choice(
                               '1',
                               '2',
                               '3',
                               '4',
                               '5',
                               '6',
                               '7',
                               '8',
                               '9',
                               'a',
                               'c',
                               'd',
                               'g',
                               'l',
                               'p',
                               's',
                               'u',
                               'w',
                               'x',
                               'n',
                               'r',
                               't',
                               '[',
                               ']',
                               '\\',
                               '$',
                               '(',
                               ')',
                               '^',
                               '"',
                               '*',
                               '.',
                               '-'
                             )
                           ),
                           seq('\\b', /[^"]/, /[^"]/),
                           seq('\\f', $.bracketclass)
                         ),
    /*
     * carp.ebnf:85
     * bracketclass     ::= '[' '^'? (range | patternescaped | [^\-\u005E\u0024()\[\]\\"]+)* ']'
     */
    bracketclass: $ => seq(
                         '[',
                         optional('^'),
                         repeat(choice($.range, $.patternescaped, repeat1(/[^\-\u005E\u0024()\[\]\\"]/))),
                         ']'
                       ),
    /*
     * carp.ebnf:87
     * range            ::= !(($ALPHANUM) '-' ($ALPHANUM))
     */
    range: $ => token.immediate(seq(/[0-9a-zA-Z]/, '-', /[0-9a-zA-Z]/)),
    /*
     * carp.ebnf:89
     * capture          ::= '(' (patternescaped | bracketclass | ($PATTERNSIMPLE))* ')'
     */
    capture: $ => seq(
                    '(',
                    repeat(choice($.patternescaped, $.bracketclass, /[^\u005E\u0024()\[\]\\"]/)),
                    ')'
                  ),
    /*
     * carp.ebnf:91-96
     * number           ::= float
     *                    | floatnoperiod
     *                    | byte
     *                    | double
     *                    | long
     *                    | integer
     */
    number: $ => choice($.float, $.floatnoperiod, $.byte, $.double, $.long, $.integer),
    /*
     * carp.ebnf:98
     * float            ::= !(($MAYBESIGNED) '.' ($DIGIT)+)
     */
    float: $ => token.immediate(seq(seq(optional('-'), repeat1(/[0-9]/)), '.', repeat1(/[0-9]/))),
    /*
     * carp.ebnf:100
     * floatnoperiod    ::= !((($BASES) | ($MAYBESIGNED)) 'f')
     */
    floatnoperiod: $ => token.immediate(
                          seq(
                            choice(
                              seq('0b', repeat1(/[0-1]/)),
                              seq('0x', repeat1(/[0-9a-fA-F]/)),
                              seq(optional('-'), repeat1(/[0-9]/))
                            ),
                            'f'
                          )
                        ),
    /*
     * carp.ebnf:102
     * byte             ::= !((($BASES) | ($MAYBESIGNED)) 'b')
     */
    byte: $ => token.immediate(
                 seq(
                   choice(
                     seq('0b', repeat1(/[0-1]/)),
                     seq('0x', repeat1(/[0-9a-fA-F]/)),
                     seq(optional('-'), repeat1(/[0-9]/))
                   ),
                   'b'
                 )
               ),
    /*
     * carp.ebnf:104
     * double           ::= !(($MAYBESIGNED) '.' ($DIGIT)+)
     */
    double: $ => token.immediate(seq(seq(optional('-'), repeat1(/[0-9]/)), '.', repeat1(/[0-9]/))),
    /*
     * carp.ebnf:106
     * long             ::= !((($BASES) | ($MAYBESIGNED)) 'l')
     */
    long: $ => token.immediate(
                 seq(
                   choice(
                     seq('0b', repeat1(/[0-1]/)),
                     seq('0x', repeat1(/[0-9a-fA-F]/)),
                     seq(optional('-'), repeat1(/[0-9]/))
                   ),
                   'l'
                 )
               ),
    /*
     * carp.ebnf:108
     * integer          ::= !(($BASES) | ($MAYBESIGNED))
     */
    integer: $ => token.immediate(
                    choice(
                      seq('0b', repeat1(/[0-1]/)),
                      seq('0x', repeat1(/[0-9a-fA-F]/)),
                      seq(optional('-'), repeat1(/[0-9]/))
                    )
                  ),
    /*
     * carp.ebnf:110
     * comment          ::= @(';' [^\n]*)
     */
    comment: $ => token(seq(';', repeat(/[^\n]/)))
  }
});
